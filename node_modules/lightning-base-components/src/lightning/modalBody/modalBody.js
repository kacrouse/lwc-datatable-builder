import { LightningElement } from 'lwc';
import { classSet } from 'lightning/utils';
import { getRealDOMId } from 'lightning/utilsPrivate';
import { findAllTabbableElements, filterTooltips } from 'lightning/focusUtils';

/**
 * The modal body component to display main content area in lightning modal.
 * */
export default class LightningModalBody extends LightningElement {
    // private tracked state
    initialRender = true;
    initialSlotRender = true;
    unregisterCallback = null;
    headerPresent = false;
    footerPresent = false;

    /**
     * Handle the default slot change event
     * Always register with parent every slot change
     * @private
     */
    handleDefaultSlotChange() {
        // Set this once so that parent can know slot has rendered
        if (this.initialSlotRender) {
            this.initialSlotRender = false;
        }
        this.registerWithParent();
    }

    /**
     * Handle the 'privatescrollablecontainer from positionLibrary.js
     * This repositions elements with overlays that use positionLibrary
     * like helptext, combobox, etc
     * @private
     */
    handleScrollableContainerRepositionEvent(event) {
        const { callback: repositionCallback } = event.detail;
        repositionCallback(event.composedPath());
        event.stopPropagation();
    }

    /**
     * Gets the CSS classes applicable to the modal body element.
     * Hidden classes included for sibling components
     * @return {string} CSS class applied to modal body
     * @private
     */
    get modalBodyCssClasses() {
        const classes = classSet('slds-modal__content slds-p-around_medium');
        classes.add({
            'slds-modal__content_headless': !this.headerPresent,
            'slds-modal__content_footless': !this.footerPresent,
        });
        return classes.toString();
    }

    /**
     * Get a reference to the modal body content area wrapper div element
     * @returns {(HTMLElement|null)} Outer wrapper for modal body
     * @private
     */
    get contentElem() {
        return this.template.querySelector('[data-content-container]');
    }

    /**
     * Get the main content div element assigned ID value
     * @type {(string|null)}
     * @private
     */
    get modalContentId() {
        return getRealDOMId(this.contentElem);
    }

    /**
     * Get the default slot element for modal body component
     * @returns {(HTMLElement|null)}
     * @private
     */
    get defaultSlotElement() {
        return this.template.querySelector('[data-default-slot]');
    }

    /**
     * Determine whether the default slot is populated
     * @returns {boolean}
     * @private
     */
    get isDefaultSlotPopulated() {
        const slotElement = this.defaultSlotElement;
        if (slotElement && slotElement.assignedNodes) {
            return slotElement.assignedNodes().length > 0;
        }
        return false;
    }

    /**
     * Get first tabbable element within modalBody, if exists
     * This is passed to parent in order to autoFocus
     * @return {(HTMLElement|null)}
     * @private
     */
    get firstTabbableElement() {
        let firstElem = null;
        if (this.isDefaultSlotPopulated) {
            const tabbableElements = findAllTabbableElements(
                this.defaultSlotElement
            );
            const filteredElements = filterTooltips(tabbableElements);
            if (filteredElements.length > 0) {
                firstElem = filteredElements[0];
            }
        }
        return firstElem;
    }

    /**
     * Set the max-height style inline on modalBody to prevent vertical height
     * of overall modal to overflow
     * This function is passed to the parent modal as a callback
     * and will be called on first modal load, and then on window resize events
     * as long as modalBody is present
     * @param {Object} values Representing headerHeight, footerHeight, backdropHeight
     * @returns {object} Representing headerHeight, footerHeight, backdropHeight
     * @private
     */
    handleUpdateHeight({ headerHeight, footerHeight, backdropHeight }) {
        if (!this.initialRender) {
            const paddingTop = 48; // 3rem
            const paddingBottom = 80; // 5rem
            const modalBodyMinHeight = 80;
            const modalUsableHeight =
                backdropHeight - paddingTop - paddingBottom;
            const modalBodyUsableHeight =
                modalUsableHeight - headerHeight - footerHeight;
            const divElem = this.contentElem;
            const styles = {
                maxHeight: `${modalBodyUsableHeight}px`,
                minHeight: `${modalBodyMinHeight}px`,
            };
            // set the max and min height value on modal body wrapper div
            Object.assign(divElem.style, styles);
            this.headerPresent = headerHeight !== 0;
            this.footerPresent = footerHeight !== 0;
        }
    }

    /**
     * Register modalBody with modal parent, including callbacks to
     * unregister the modal body, and update the modal body height
     * this will get called multiple times over component lifecycle
     * @type {CustomEvent}
     * @private
     */
    registerWithParent() {
        const evtRegister = new CustomEvent('privatemodalbodyregister', {
            bubbles: true,
            composed: true,
            detail: {
                bodyId: this.modalContentId,
                bodyIsPopulated: this.isDefaultSlotPopulated,
                defaultSlotHasRendered: !this.initialSlotRender,
                updateBodyCallback: this.handleUpdateHeight.bind(this),
                unRegisterCallback: (unregisterCallback) => {
                    this.unregisterCallback = unregisterCallback;
                },
                firstTabbableElemRef: this.firstTabbableElement,
            },
        });
        this.dispatchEvent(evtRegister);
    }

    /**
     * When modal body is being created, initialize
     * private tracked modal body state
     * @private
     */
    initState() {
        this.initialRender = true;
        this.initialSlotRender = true;
        this.unregisterCallback = null;
        this.headerPresent = false;
        this.footerPresent = false;
    }

    connectedCallback() {
        // handle case where modalBody is added/removed/re-added to DOM
        this.initState();
    }

    disconnectedCallback() {
        if (this.unregisterCallback) {
            this.unregisterCallback();
        }
    }

    renderedCallback() {
        if (this.initialRender) {
            this.registerWithParent();
            this.initialRender = false;
        }
    }
}
