const {
  apply: ReflectApply,
  defineProperty: ReflectDefineProperty,
  deleteProperty: ReflectDeleteProperty,
  getPrototypeOf: ReflectGetPrototypeOf,
  ownKeys: ReflectOwnKeys,
  setPrototypeOf: ReflectSetPrototypeOf
} = Reflect;
const ObjectCtor = Object;
const {
  assign: ObjectAssign,
  freeze: ObjectFreeze,
  keys: ObjectKeys,
  prototype: ObjectProto
} = ObjectCtor;
const {
  hasOwn: OriginalObjectHasOwn
} = ObjectCtor;
const {
  __lookupGetter__: ObjectProtoLookupGetter,
  __lookupSetter__: ObjectProtoLookupSetter,
  hasOwnProperty: ObjectProtoHasOwnProperty
} = ObjectProto;
const ObjectHasOwn = typeof OriginalObjectHasOwn === 'function' ? OriginalObjectHasOwn :
/* istanbul ignore next: currently unreachable via tests */
function ObjectHasOwn(object, key) {
  return ReflectApply(ObjectProtoHasOwnProperty, object, [key]);
};
const {
  toString: ObjectProtoToString
} = ObjectProto;

function isObject(value) {
  return typeof value === 'object' && value !== null;
}

function ObjectLookupOwnGetter(object, key) {
  return object === null || object === undefined || !ObjectHasOwn(object, key) ? undefined : ReflectApply(ObjectProtoLookupGetter, object, [key]);
}

function ObjectLookupOwnSetter(object, key) {
  return object === null || object === undefined || !ObjectHasOwn(object, key) ? undefined : ReflectApply(ObjectProtoLookupSetter, object, [key]);
}

const SymbolCtor = Symbol;
const {
  for: SymbolFor,
  iterator: SymbolIterator,
  toStringTag: SymbolToStringTag,
  unscopables: SymbolUnscopables
} = SymbolCtor;
const {
  valueOf: SymbolProtoValueOf
} = SymbolCtor.prototype;
const ArrayCtor = Array;
const {
  prototype: ArrayProto
} = ArrayCtor;
const {
  at: ArrayProtoAt,
  concat: ArrayProtoConcat,
  copyWithin: ArrayProtoCopyWithin,
  entries: ArrayProtoEntries,
  every: ArrayProtoEvery,
  fill: ArrayProtoFill,
  findIndex: ArrayProtoFindIndex,
  flat: ArrayProtoFlat,
  flatMap: ArrayProtoFlatMap,
  forEach: ArrayProtoForEach,
  indexOf: ArrayProtoIndexOf,
  join: ArrayProtoJoin,
  keys: ArrayProtoKeys,
  lastIndexOf: ArrayProtoLastIndexOf,
  map: ArrayProtoMap,
  pop: ArrayProtoPop,
  reduce: ArrayProtoReduce,
  reduceRight: ArrayProtoReduceRight,
  reverse: ArrayProtoReverse,
  slice: ArrayProtoSlice,
  some: ArrayProtoSome,
  splice: ArrayProtoSplice,
  toLocaleString: ArrayProtoToLocaleString,
  toString: ArrayProtoToString,
  values: ArrayProtoValues,
  [SymbolIterator]: ArrayProtoSymbolIterator
} = ArrayProto;
const ArrayUnscopables = ObjectFreeze(ObjectAssign({
  __proto__: null
}, ArrayProto[SymbolUnscopables]));
const {
  filter: ArrayProtoFilter,
  find: ArrayProtoFind,
  includes: ArrayProtoIncludes,
  shift: ArrayProtoShift,
  sort: ArrayProtoSort,
  unshift: ArrayProtoUnshift
} = ArrayProto;
const {
  push: ArrayProtoPush
} = ArrayProto;
const {
  isArray: ArrayIsArray
} = ArrayCtor;

function toSafeArray(array) {
  ReflectSetPrototypeOf(array, null);
  array.at = ArrayProtoAt;
  array.concat = ArrayProtoConcat; // *** DO NOT SET THE ARRAY CONSTRUCTOR PROPERTY ***
  // https://bugs.chromium.org/p/v8/issues/detail?id=13202
  // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/lookup.cc;l=196-215?q=IsArraySpeciesLookupChainIntact
  //
  // In V8 setting the constructor property of an array, promise, regexp, or
  // typed array triggers a de-opt because it could change an instance's
  // @@species. This de-opt affects at least `Array#splice` and occurs even
  // if the prototype of the array is change or nulled beforehand. Further,
  // the de-opt persists after a page refresh. It is not until navigating to
  // a different page that the performance of `Array#splice` is restored.

  array.copyWithin = ArrayProtoCopyWithin;
  array.entries = ArrayProtoEntries;
  array.every = ArrayProtoEvery;
  array.fill = ArrayProtoFill;
  array.filter = ArrayProtoFilter;
  array.find = ArrayProtoFind;
  array.findIndex = ArrayProtoFindIndex;
  array.flat = ArrayProtoFlat;
  array.flatMap = ArrayProtoFlatMap;
  array.forEach = ArrayProtoForEach;
  array.includes = ArrayProtoIncludes;
  array.indexOf = ArrayProtoIndexOf;
  array.join = ArrayProtoJoin;
  array.keys = ArrayProtoKeys;
  array.lastIndexOf = ArrayProtoLastIndexOf;
  array.map = ArrayProtoMap;
  array.pop = ArrayProtoPop;
  array.push = ArrayProtoPush;
  array.reduce = ArrayProtoReduce;
  array.reduceRight = ArrayProtoReduceRight;
  array.reverse = ArrayProtoReverse;
  array.shift = ArrayProtoShift;
  array.slice = ArrayProtoSlice;
  array.some = ArrayProtoSome;
  array.sort = ArrayProtoSort;
  array.splice = ArrayProtoSplice;
  array.toLocaleString = ArrayProtoToLocaleString;
  array.toString = ArrayProtoToString;
  array.unshift = ArrayProtoUnshift;
  array.values = ArrayProtoValues;
  array[SymbolIterator] = ArrayProtoSymbolIterator;
  array[SymbolUnscopables] = ArrayUnscopables;
  ReflectSetPrototypeOf(array, ArrayProto);
  return array;
}

const ArrayBufferProtoByteLengthGetter = ObjectLookupOwnGetter(ArrayBuffer.prototype, 'byteLength'); // https://caniuse.com/bigint

const SUPPORTS_BIG_INT = typeof BigInt === 'function';
const BigIntProtoValueOf = SUPPORTS_BIG_INT ? BigInt.prototype.valueOf :
/* istanbul ignore next: currently unreachable via tests */
undefined;
const {
  valueOf: BooleanProtoValueOf
} = Boolean.prototype;
const LOCKER_IDENTIFIER_MARKER = '$LWS'; // This package is bundled by third-parties that have their own build time
// replacement logic. Instead of customizing each build system to be aware
// of this package we implement a two phase debug mode by performing small
// runtime checks to determine phase one, our code is unminified, and
// phase two, the user opted-in to custom devtools formatters. Phase one
// is used for light weight initialization time debug while phase two is
// reserved for post initialization runtime.

const LOCKER_UNMINIFIED_FLAG = // eslint-disable-next-line @typescript-eslint/naming-convention

/* istanbul ignore next */
`${function LOCKER_UNMINIFIED_FLAG() {
  return LOCKER_UNMINIFIED_FLAG.name;
}()}`.includes('LOCKER_UNMINIFIED_FLAG');
const CHAR_ELLIPSIS = '\u2026';
const TO_STRING_BRAND_ARRAY = '[object Array]';
const TO_STRING_BRAND_ARRAY_BUFFER = '[object ArrayBuffer]';
const TO_STRING_BRAND_BIG_INT = '[object BigInt]';
const TO_STRING_BRAND_BOOLEAN = '[object Boolean]';
const TO_STRING_BRAND_DATE = '[object Date]';
const TO_STRING_BRAND_FUNCTION = '[object Function]';
const TO_STRING_BRAND_MAP = '[object Map]';
const TO_STRING_BRAND_NULL = '[object Null]';
const TO_STRING_BRAND_NUMBER = '[object Number]';
const TO_STRING_BRAND_OBJECT = '[object Object]';
const TO_STRING_BRAND_REG_EXP = '[object RegExp]';
const TO_STRING_BRAND_SET = '[object Set]';
const TO_STRING_BRAND_STRING = '[object String]';
const TO_STRING_BRAND_SYMBOL = '[object Symbol]';
const TO_STRING_BRAND_UNDEFINED = '[object Undefined]';
const TO_STRING_BRAND_WEAK_MAP = '[object WeakMap]';
const TO_STRING_BRAND_WEAK_SET = '[object WeakSet]';
const {
  valueOf: DateProtoValueOf
} = Date.prototype;
const MapCtor = Map;
const {
  prototype: MapProto
} = MapCtor;
const {
  clear: MapProtoClear,
  delete: MapProtoDelete,
  forEach: MapProtoForEach,
  get: MapProtoGet,
  has: MapProtoHas,
  keys: MapProtoKeys,
  values: MapProtoValues,
  [SymbolIterator]: MapProtoSymbolIterator,
  [SymbolToStringTag]: MapProtoSymbolToStringTag
} = MapProto;
const {
  entries: MapProtoEntries,
  set: MapProtoSet
} = MapProto;
const MapProtoSizeGetter = ObjectLookupOwnGetter(MapProto, 'size');

function toSafeMap(map) {
  ReflectSetPrototypeOf(map, null);
  map.clear = MapProtoClear;
  map.delete = MapProtoDelete;
  map.entries = MapProtoEntries;
  map.forEach = MapProtoForEach;
  map.get = MapProtoGet;
  map.has = MapProtoHas;
  map.keys = MapProtoKeys;
  map.set = MapProtoSet;
  ReflectDefineProperty(map, 'size', {
    __proto__: null,
    configurable: true,
    enumerable: true,
    get: MapProtoSizeGetter,
    set: undefined
  });
  map.values = MapProtoValues;
  map[SymbolIterator] = MapProtoSymbolIterator;
  map[SymbolToStringTag] = MapProtoSymbolToStringTag;
  ReflectSetPrototypeOf(map, MapProto);
  return map;
}

const NumberCtor = Number;
const {
  isFinite: NumberIsFinite,
  isInteger: NumberIsInteger
} = NumberCtor;
const {
  valueOf: NumberProtoValueOf
} = NumberCtor.prototype;
const RegExpCtor = RegExp;
const {
  prototype: RegExpProto
} = RegExpCtor;
const {
  test: RegExpProtoTest
} = RegExpProto;
const RegExpProtoSourceGetter = ObjectLookupOwnGetter(RegExpProto, 'source');
const SetCtor = Set;
const {
  prototype: SetProto
} = SetCtor;
const {
  add: SetProtoAdd,
  values: SetProtoValues
} = SetProto;
const SetProtoSizeGetter = ObjectLookupOwnGetter(SetProto, 'size');
const StringCtor = String;
const {
  prototype: StringProto
} = StringCtor;
const {
  slice: StringProtoSlice,
  valueOf: StringProtoValueOf
} = StringProto;
const WeakMapCtor = WeakMap;
const {
  prototype: WeakMapProto
} = WeakMapCtor;
const {
  has: WeakMapProtoHas
} = WeakMapProto;
const {
  delete: WeakMapProtoDelete,
  get: WeakMapProtoGet,
  set: WeakMapProtoSet,
  [SymbolToStringTag]: WeakMapProtoSymbolToStringTag
} = WeakMapProto;

function toSafeWeakMap(weakMap) {
  ReflectSetPrototypeOf(weakMap, null);
  weakMap.delete = WeakMapProtoDelete;
  weakMap.get = WeakMapProtoGet;
  weakMap.has = WeakMapProtoHas;
  weakMap.set = WeakMapProtoSet;
  weakMap[SymbolToStringTag] = WeakMapProtoSymbolToStringTag;
  ReflectSetPrototypeOf(weakMap, WeakMapProto);
  return weakMap;
}

const {
  has: WeakSetProtoHas
} = WeakSet.prototype;
const {
  toStringTag: TO_STRING_TAG_SYMBOL
} = Symbol;

function getBrandByTrialAndError(value) {
  // Trail and error attempts are performed in order of most likely,
  // e.g. those values that have a @@toStringTag defined by default,
  // to least likely.
  //
  // Internally these brand checks rely on native methods that throw and catch
  // an exception when they operate on values with unexpected internal slot
  // entries.
  // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
  // https://tc39.es/ecma262/#sec-get-arraybuffer.prototype.bytelength
  // Step 2: Perform RequireInternalSlot(O, [[ArrayBufferData]]).
  try {
    if ('byteLength' in value) {
      ReflectApply(ArrayBufferProtoByteLengthGetter, value, []);
      return TO_STRING_BRAND_ARRAY_BUFFER;
    } // eslint-disable-next-line no-empty

  } catch (_unused) {} // Section 21.4.4 Properties of the Date Prototype Object
  // https://tc39.es/ecma262/#thistimevalue
  // Step 1: If Type(value) is Object and value has a [[DateValue]] internal slot, then
  //     a. Return value.[[DateValue]].
  // Step 2: Throw a TypeError exception.


  try {
    if ('toLocaleDateString' in value) {
      ReflectApply(DateProtoValueOf, value, []);
      return TO_STRING_BRAND_DATE;
    } // eslint-disable-next-line no-empty

  } catch (_unused2) {} // Section 24.1.3.10 get Map.prototype.size
  // https://tc39.es/ecma262/#sec-get-map.prototype.size
  // Step 2: Perform ? RequireInternalSlot(M, [[MapData]]).


  try {
    if ('get' in value && 'size' in value) {
      ReflectApply(MapProtoSizeGetter, value, []);
      return TO_STRING_BRAND_MAP;
    } // eslint-disable-next-line no-empty

  } catch (_unused3) {} // Section 24.2.3.9 get Set.prototype.size
  // https://tc39.es/ecma262/#sec-get-set.prototype.size
  // Step 2: Perform ? RequireInternalSlot(S, [[SetData]]).


  try {
    if ('add' in value && 'size' in value) {
      ReflectApply(SetProtoSizeGetter, value, []);
      return TO_STRING_BRAND_SET;
    } // eslint-disable-next-line no-empty

  } catch (_unused4) {} // Section 24.3.3.4 WeakMap.prototype.has ( key )
  // https://tc39.es/ecma262/#sec-weakmap.prototype.has
  // Step 2: Perform RequireInternalSlot(M, [[WeakMapData]]).


  try {
    if ('get' in value && !('size' in value)) {
      ReflectApply(WeakMapProtoHas, value, []);
      return TO_STRING_BRAND_WEAK_MAP;
    } // eslint-disable-next-line no-empty

  } catch (_unused5) {} // Section 24.4.3.4 WeakSet.prototype.has ( value )
  // https://tc39.es/ecma262/#sec-weakset.prototype.has
  // Step 2: 2. Perform RequireInternalSlot(S, [[WeakSetData]]).


  try {
    if ('add' in value && !('size' in value)) {
      ReflectApply(WeakSetProtoHas, value, []);
      return TO_STRING_BRAND_WEAK_SET;
    } // eslint-disable-next-line no-empty

  } catch (_unused6) {} // The following checks are for the rare occurrence of object, i.e. boxed,
  // primitive values or those objects without a default @@toStringTag.
  // Section 21.1.3 Properties of the Number Prototype Object
  // https://tc39.es/ecma262/#thisnumbervalue
  // Step 2: If Type(value) is Object and value has a [[NumberData]] internal slot, then
  //     a. Let n be value.[[NumberData]].
  //     b. Assert: Type(n) is Number.


  try {
    if ('toPrecision' in value) {
      ReflectApply(NumberProtoValueOf, value, []);
      return TO_STRING_BRAND_NUMBER;
    } // eslint-disable-next-line no-empty

  } catch (_unused7) {} // Section 20.4.3 Properties of the Symbol Prototype Object
  // https://tc39.es/ecma262/#thissymbolvalue
  // Step 2: If Type(value) is Object and value has a [[SymbolData]] internal slot, then
  //     a. Let s be value.[[SymbolData]].
  //     b. Assert: Type(s) is Symbol.


  try {
    if ('description' in value) {
      ReflectApply(SymbolProtoValueOf, value, []);
      return TO_STRING_BRAND_SYMBOL;
    } // eslint-disable-next-line no-empty

  } catch (_unused8) {} // Perform heavier checks last.
  // Section 22.2.6.13 get RegExp.prototype.source
  // https://tc39.es/ecma262/#sec-get-regexp.prototype.source
  // Step 3: If R does not have an [[OriginalSource]] internal slot, then
  //     a. If SameValue(R, %RegExp.prototype%) is true, return "(?:)".
  //     b. Otherwise, throw a TypeError exception.


  try {
    if (ObjectHasOwn(value, 'lastIndex')) {
      ReflectApply(RegExpProtoSourceGetter, value, []);
      return TO_STRING_BRAND_REG_EXP;
    } // eslint-disable-next-line no-empty

  } catch (_unused9) {} // Section 22.1.3 Properties of the String Prototype Object
  // https://tc39.es/ecma262/#thisstringvalue
  // Step 2: If Type(value) is Object and value has a [[StringData]] internal slot, then
  //     a. Let s be value.[[StringData]].
  //     b. Assert: Type(s) is String.


  try {
    if (ObjectHasOwn(value, 'length')) {
      ReflectApply(StringProtoValueOf, value, []);
      return TO_STRING_BRAND_STRING;
    } // eslint-disable-next-line no-empty

  } catch (_unused10) {} // Section 20.3.3 Properties of the Boolean Prototype Object
  // https://tc39.es/ecma262/#thisbooleanvalue
  // Step 2: If Type(value) is Object and value has a [[BooleanData]] internal slot, then
  //     a. Let b be value.[[BooleanData]].
  //     b. Assert: Type(b) is Boolean.


  try {
    ReflectApply(BooleanProtoValueOf, value, []);
    return TO_STRING_BRAND_BOOLEAN; // eslint-disable-next-line no-empty
  } catch (_unused11) {} // istanbul ignore else: All platforms that LWS runs tests in support BigInt


  if (SUPPORTS_BIG_INT) {
    try {
      // Section 21.2.3 Properties of the BigInt Prototype Object
      // https://tc39.es/ecma262/#thisbigintvalue
      // Step 2: If Type(value) is Object and value has a [[BigIntData]] internal slot, then
      //     a. Assert: Type(value.[[BigIntData]]) is BigInt.
      ReflectApply(BigIntProtoValueOf, value, []);
      return TO_STRING_BRAND_BIG_INT; // eslint-disable-next-line no-empty
    } catch (_unused12) {}
  } // Cannot detect brands for Arguments and Error objects.


  return TO_STRING_BRAND_OBJECT;
}

function getBrand(value) {
  // Section 20.1.3.6 Object.prototype.toString ( )
  // https://tc39.es/ecma262/#sec-object.prototype.tostring
  if (value === null) {
    return TO_STRING_BRAND_NULL;
  }

  if (value === undefined) {
    return TO_STRING_BRAND_UNDEFINED;
  } // eslint-disable-next-line default-case


  switch (typeof value) {
    case 'bigint':
      return TO_STRING_BRAND_BIG_INT;

    case 'boolean':
      return TO_STRING_BRAND_BOOLEAN;

    case 'function':
      return TO_STRING_BRAND_FUNCTION;

    case 'number':
      return TO_STRING_BRAND_NUMBER;

    case 'string':
      return TO_STRING_BRAND_STRING;

    case 'symbol':
      return TO_STRING_BRAND_SYMBOL;
  }

  if (ArrayIsArray(value)) {
    return TO_STRING_BRAND_ARRAY;
  }

  return TO_STRING_TAG_SYMBOL in value ? getBrandByTrialAndError(value) : ReflectApply(ObjectProtoToString, value, []);
}

const {
  parse: JSONParse
} = JSON; // Used by '@locker/near-membrane-dom'.

const {
  stringify: JSONStringify
} = JSON;
const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL = SymbolFor('@@lockerNearMembraneSerializedValue');
const LOCKER_NEAR_MEMBRANE_SYMBOL = SymbolFor('@@lockerNearMembrane');

function getNearMembraneSerializedValue(object) {
  return LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL in object ? undefined : object[LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL];
}

function isNearMembrane(value) {
  if (typeof value === 'object' && value !== null || typeof value === 'function') {
    return !(LOCKER_NEAR_MEMBRANE_SYMBOL in value) && value[LOCKER_NEAR_MEMBRANE_SYMBOL] === true;
  }

  return false;
}

const SEEN_OBJECTS_MAP = toSafeMap(new MapCtor());

function cloneBoxedPrimitive(object) {
  return ObjectCtor(getNearMembraneSerializedValue(object));
}

function cloneMap(map, queue) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.1.1: Let copiedList be a new empty List.
  const clone = new MapCtor(); // Step 26.1.2: For each Record { [[Key]], [[Value]] } entry of value.[[MapData]]...

  const entriesIterable = ReflectApply(MapProtoEntries, map, []); // Step 26.1.3 For each Record { [[Key]], [[Value]] } entry of copiedList:

  let {
    length: queueOffset
  } = queue; // eslint-disable-next-line no-constant-condition

  while (true) {
    const {
      done,
      value: subKeyValuePair
    } = entriesIterable.next();

    if (done) {
      break;
    }

    const {
      0: subKey,
      1: subValue
    } = subKeyValuePair;
    let subCloneKey; // Step 26.1.3.1: Let serializedKey be ? StructuredSerializeInternal(entry.[[Key]], forStorage, memory).

    queue[queueOffset++] = [subClone => {
      subCloneKey = subClone;
    }, subKey]; // Step 26.1.3.2: Let serializedValue be ? StructuredSerializeInternal(entry.[[Value]], forStorage, memory).

    queue[queueOffset++] = [subCloneValue => {
      ReflectApply(MapProtoSet, clone, [subCloneKey, subCloneValue]);
    }, subValue];
  }

  return clone;
}

function cloneRegExp(regexp) {
  const {
    flags,
    source
  } = JSONParse(getNearMembraneSerializedValue(regexp));
  return new RegExpCtor(source, flags);
}

function cloneSet(set, queue) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.2.1: Let copiedList be a new empty List.
  const clone = new SetCtor(); // Step 26.2.2: For each entry of value.[[SetData]]...

  const valuesIterable = ReflectApply(SetProtoValues, set, []); // Step 26.2.3: For each entry of copiedList:

  let {
    length: queueOffset
  } = queue; // eslint-disable-next-line no-constant-condition

  while (true) {
    const {
      done,
      value: subValue
    } = valuesIterable.next();

    if (done) {
      break;
    } // Step 26.2.3.1: Let serializedEntry be ? StructuredSerializeInternal(entry, forStorage, memory).


    queue[queueOffset++] = [subCloneValue => {
      ReflectApply(SetProtoAdd, clone, [subCloneValue]);
    }, subValue];
  }

  return clone;
}

function enqueue(queue, originalValue, cloneValue) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.4: Otherwise, for each key in ! EnumerableOwnPropertyNames(value, key)...
  // Note: Object.keys() performs EnumerableOwnPropertyNames() internally as
  // defined in ECMA262:
  // https://tc39.es/ecma262/#sec-object.keys
  const keys = ObjectKeys(originalValue);
  let {
    length: queueOffset
  } = queue;

  for (let i = 0, {
    length
  } = keys; i < length; i += 1) {
    // Step 26.4.1.1: Let inputValue be ? value.[[Get]](key, value).
    // The [[Get]] operation is defined in ECMA262 for ordinary objects,
    // argument objects, integer-indexed exotic objects, module namespace
    // objects, and proxy objects.
    // https://tc39.es/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver
    const key = keys[i];
    const subValue = originalValue[key];
    queue[queueOffset++] = [subCloneValue => {
      // Step 26.4.1.3: Property descriptor attributes are not
      // preserved during deserialization because only keys and
      // values are captured in serialized.[[Properties]].
      cloneValue[key] = subCloneValue;
    }, subValue];
  }
} // This function is the unguarded internal variant of `partialStructuredClone()`.
// Any error thrown that is captured by `partialStructuredClone()` is treated as
// a `DataCloneError`. This function clones blue membrane proxied arrays, plain
// objects, maps, regexps, sets, and boxed primitives. The following non-membrane
// proxied objects are set by reference instead of cloning:
//   ArrayBuffer
//   BigInt64Array
//   BigUint64Array
//   Blob
//   DataView
//   Date
//   DOMException
//   DOMMatrix
//   DOMMatrixReadOnly
//   DOMPoint
//   DOMPointReadOnly
//   DOMQuad
//   DOMRect
//   DOMRectReadOnly
//   Error
//   EvalError
//   File
//   FileList
//   Float32Array
//   Float64Array
//   ImageBitMap
//   ImageData
//   Int8Array
//   Int16Array
//   Int32Array
//   RangeError
//   ReferenceError
//   SyntaxError
//   TypeError
//   Uint8Array
//   Uint8ClampedArray
//   Uint16Array
//   Uint32Array
//   URIError
//
// Note:
// This function performs brand checks using `Object.prototype.toString`. The
// results can be faked with `Symbol.toStringTag` property values and are a poor
// substitute for native internal slot checks. However, for our purposes they
// are perfectly fine and avoid having to repeatedly walk the prototype of proxied
// values. Cloned values should be passed to native methods, like `postMessage()`,
// which perform their own validation with internal slot checks.


function partialStructuredCloneInternal(value) {
  // Using a queue instead of recursive function calls avoids call stack limits
  // and enables cloning more complex and deeply nested objects.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Too_much_recursion
  let result;
  const queue = [[subClone => {
    result = subClone;
  }, value]]; // eslint-disable-next-line no-labels

  queueLoop: while (queue.length) {
    // Section 2.7.3 StructuredSerializeInternal:
    // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
    // prettier-ignore
    const {
      0: setter,
      1: originalValue
    } = ReflectApply(ArrayProtoShift, queue, []); // Step 4: If Type(value) is Undefined, Null, Boolean, Number, BigInt, or String

    if (originalValue === null || originalValue === undefined || typeof originalValue === 'boolean' || typeof originalValue === 'number' || typeof originalValue === 'string' || typeof originalValue === 'bigint') {
      setter(originalValue); // eslint-disable-next-line no-continue, no-extra-label, no-labels

      continue queueLoop;
    } // Step 5: If Type(value) is Symbol, then throw a 'DataCloneError' DOMException.


    if (typeof originalValue === 'symbol') {
      // Stop cloning and set the original value and defer throwing to
      // native methods.
      setter(originalValue); // eslint-disable-next-line no-extra-label, no-labels

      break queueLoop;
    } // To support circular references check if the original value has been
    // seen. If it has then use the clone associated with its record instead
    // of creating a new clone.


    let cloneValue = SEEN_OBJECTS_MAP.get(originalValue);

    if (cloneValue) {
      setter(cloneValue); // eslint-disable-next-line no-continue, no-extra-label, no-labels

      continue queueLoop;
    } // Perform a brand check on originalValue.


    const brand = getBrand(originalValue); // eslint-disable-next-line default-case

    switch (brand) {
      // Step 19: Otherwise, if value is a platform object...
      case TO_STRING_BRAND_OBJECT:
        {
          const proto = ReflectGetPrototypeOf(originalValue);

          if (proto === ObjectProto || proto === null || // Possible `Object.prototype` from another document.
          ReflectGetPrototypeOf(proto) === null) {
            cloneValue = {}; // Step 19.4: Set deep to true.

            enqueue(queue, originalValue, cloneValue);
          }

          break;
        }
      // Step 18: Otherwise, if value is an Array exotic object...

      case TO_STRING_BRAND_ARRAY:
        // Step 18.1 Let valueLenDescriptor be ? OrdinaryGetOwnProperty(value, 'length').
        // Note: Rather than perform the more complex OrdinaryGetOwnProperty()
        // operation for 'length' because it is a non-configurable property
        // we can access it with the simpler [[Get]]() operation defined
        // in ECMA262.
        // https://tc39.es/ecma262/#sec-integer-indexed-exotic-objects-get-p-receiver
        cloneValue = ArrayCtor(originalValue.length); // Step 18.4: Set deep to true.

        enqueue(queue, originalValue, cloneValue);
        break;
      // Step 15: Otherwise, if value has [[MapData]] internal slot...
      // Step 15.2: Set deep to true.

      case TO_STRING_BRAND_MAP:
        cloneValue = cloneMap(originalValue, queue);
        break;
      // Step 16: Otherwise, if value has [[SetData]] internal slot...
      // Step 16.2: Set deep to true.

      case TO_STRING_BRAND_SET:
        cloneValue = cloneSet(originalValue, queue);
        break;
    }

    if (cloneValue === undefined) {
      // istanbul ignore else
      if (!isNearMembrane(originalValue)) {
        // Skip cloning non-membrane proxied objects.
        SEEN_OBJECTS_MAP.set(originalValue, originalValue);
        setter(originalValue); // eslint-disable-next-line no-extra-label, no-labels

        continue queueLoop;
      } // Cases ordered by a guestimate on frequency of encounter.
      // eslint-disable-next-line default-case


      switch (brand) {
        // Step 12: Otherwise, if value has a [[RegExpMatcher]] internal slot...
        case TO_STRING_BRAND_REG_EXP:
          cloneValue = cloneRegExp(originalValue);
          break;
        // Step 7: If value has a [[BooleanData]] internal slot...

        case TO_STRING_BRAND_BOOLEAN: // Step 8: Otherwise, if value has a [[NumberData]] internal slot...
        // eslint-disable-next-line no-fallthrough

        case TO_STRING_BRAND_NUMBER: // Step 9: Otherwise, if value has a [[BigIntData]] internal slot...
        // eslint-disable-next-line no-fallthrough

        case TO_STRING_BRAND_BIG_INT: // Step 10: Otherwise, if value has a [[StringData]] internal slot...
        // eslint-disable-next-line no-fallthrough

        case TO_STRING_BRAND_STRING:
          cloneValue = cloneBoxedPrimitive(originalValue);
          break;
      }
    } // Step 21: Otherwise, if IsCallable(value) is true, then throw a 'DataCloneError'
    // Step 20: Otherwise, if value is a platform object, then throw a 'DataCloneError'


    if (cloneValue === undefined) {
      // Stop cloning and set the original value and defer throwing to
      // native methods.
      setter(originalValue); // eslint-disable-next-line no-extra-label, no-labels

      break queueLoop;
    }

    SEEN_OBJECTS_MAP.set(originalValue, cloneValue);
    setter(cloneValue);
  }

  return result;
}

function partialStructuredClone(value) {
  let result = value;

  try {
    result = partialStructuredCloneInternal(value); // eslint-disable-next-line no-empty
  } catch (_unused13) {}

  SEEN_OBJECTS_MAP.clear();
  return result;
}

const ErrorCtor = Error;
const TypeErrorCtor = TypeError;

function noop() {// No operation performed.
} // Used by '@locker/near-membrane-dom'.


const {
  min: MathMin
} = Math;
export { ArrayBufferProtoByteLengthGetter, ArrayCtor, ArrayIsArray, ArrayProtoFilter, ArrayProtoFind, ArrayProtoIncludes, ArrayProtoPush, ArrayProtoShift, ArrayProtoSort, ArrayProtoUnshift, BigIntProtoValueOf, BooleanProtoValueOf, CHAR_ELLIPSIS, DateProtoValueOf, ErrorCtor, JSONParse, JSONStringify, LOCKER_IDENTIFIER_MARKER, LOCKER_UNMINIFIED_FLAG, MapCtor, MapProtoEntries, MapProtoSet, MapProtoSizeGetter, MathMin, NumberIsFinite, NumberIsInteger, NumberProtoValueOf, ObjectAssign, ObjectCtor, ObjectFreeze, ObjectHasOwn, ObjectKeys, ObjectLookupOwnGetter, ObjectLookupOwnSetter, ObjectProto, ObjectProtoToString, ReflectApply, ReflectDefineProperty, ReflectDeleteProperty, ReflectGetPrototypeOf, ReflectOwnKeys, ReflectSetPrototypeOf, RegExpCtor, RegExpProtoSourceGetter, RegExpProtoTest, SUPPORTS_BIG_INT, SetCtor, SetProtoAdd, SetProtoSizeGetter, SetProtoValues, StringCtor, StringProtoSlice, StringProtoValueOf, SymbolFor, SymbolIterator, SymbolProtoValueOf, SymbolToStringTag, SymbolUnscopables, TO_STRING_BRAND_ARRAY, TO_STRING_BRAND_ARRAY_BUFFER, TO_STRING_BRAND_BIG_INT, TO_STRING_BRAND_BOOLEAN, TO_STRING_BRAND_DATE, TO_STRING_BRAND_FUNCTION, TO_STRING_BRAND_MAP, TO_STRING_BRAND_NULL, TO_STRING_BRAND_NUMBER, TO_STRING_BRAND_OBJECT, TO_STRING_BRAND_REG_EXP, TO_STRING_BRAND_SET, TO_STRING_BRAND_STRING, TO_STRING_BRAND_SYMBOL, TO_STRING_BRAND_UNDEFINED, TO_STRING_BRAND_WEAK_MAP, TO_STRING_BRAND_WEAK_SET, TypeErrorCtor, WeakMapCtor, WeakMapProtoHas, WeakSetProtoHas, getBrand, getNearMembraneSerializedValue, isNearMembrane, isObject, noop, partialStructuredClone, toSafeArray, toSafeMap, toSafeWeakMap };
